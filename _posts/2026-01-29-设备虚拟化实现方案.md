---
layout: post
title: "设备虚拟化实现方案"
date: 2026-01-29 14:00:00 +0800
categories: 技术 虚拟化
excerpt: "深入探讨如何在保证性能的情况下安全地将TPU/GPU/CPU分配给多个用户,并保证他们之间互不干扰。介绍VFIO物理直通、SR-IOV、VFIO MDEV、MIG等多种虚拟化实现方法及其核心框架。"
---

本文探讨如何在保证性能的情况下安全地将TPU/GPU/CPU分配给多个用户,并保证他们之间互不干扰,同时尽可能实现虚拟化特性。

## 要做些什么

如何把一块儿TPU/GPU/CPU在保证性能的情况下安全的分给多个用户,并保证他们之间互不干扰.并且尽可能保证虚拟化特性的实现.

## 实现方法

1. VFIO物理直通(最直观的方法)

   *   引出两个在这种模式下无法实现的虚拟化特性:

       *   热迁移
       *   灵活切分

2. SR-IOV(Single Root I/O Virtualization)

   > 每个VF有独立的BDF(总线设备号),IOMMU硬件能识别并直接隔离.BDF:（Bus\:Device\:Function/总线号:设备号:功能号）

   *   PF(Physical Function)动态创建多个VF(Virtual Function),每一个VF都有独立的BDF

       *   **PF (Physical Function)**：拥有完整的控制权，可以读写所有的硬件寄存器，负责初始化硬件
       *   **VF (Virtual Function)**：只拥有数据面的寄存器。例如，网卡的 VF 只有发送/接收队列的指针，而没有修改链路速率的权限。生成的数量有严格的限制,由硬件电路设计、PCIE规范以及系统资源共同决定的

   * 虚拟化设备的数量有限

   * 在SR-IOV模式下不支持热迁移及虚机快照等虚拟化特性

     * 本质上和VFIO物理直通方式一样,虚机直接直通到宿主机的device,无法获得虚机运行时复杂的设备状态,以及脏页无法被追踪.

       > VF通过IOMMU直接将DMA地址映射到guest物理内存,不经过KVM的页表,会导致KVM不知道那些页表被VF修改,dirty\_bitmap无法更新.

     * VM 从服务器 A 迁到服务器 B，即使 B 也有同样的显卡和 VF，但 B 上的 VF 硬件状态（比如内部流水线指针、缓存数据）与 A 上的完全不同

3. VFIO MDEV

   *   软件层实现:多个vGPU共享一个物理BDF
   *   vfio-mdev驱动将一个被虚拟出来的mdev设备封装成标准的vfio-device，最终呈现给用户空间。

4. MIG(Multi-Instance GPU)

   *   实现逻辑 : 在硬件内部将 GPU 彻底“物理隔离”。不仅是显存，连 L2 缓存、内存带宽和计算核心（SM）都被切开。
   *   **特点:**

       *   **零干扰**：一个实例的负载完全不会影响另一个实例（SR-IOV/vGPU 在高负载下仍会有资源竞争）。
       *   **组合使用**：可以把一个物理 GPU 切成 n 个 MIG 实例，然后通过 **VFIO** 把每一个实例当作一个独立的设备分配给不同的容器或 VM。

# VFIO核心框架(3min)

VFIO的设计哲学是层次化的，用户空间必须按顺序创建和关联Container、Group和Device，最终才能访问到物理设备。

访问路径 : 用户空间 → Device fd → Group → Container → IOMMU → 物理设备

## Container

*   为所有关联的Group提供统一的IOMMU地址空间,支持多个group

## Group

*   在一个group中的就是共享某个设备,IOMMU无法隔离它们,如果想使用该组里面的某种设备,必须把整个组进行直通
*   group是硬件强制的 : 由IOMMU拓扑决定 , 无法改变

## Device

*   具体的硬件设备

# VFIO MDEV框架(7min)

> VFIO-PCI实现了设备的物理直通,它存在一个核心限制:独占性.
>
> 一个物理设备一旦被分配给一个虚拟机,其他虚拟机或宿主机便无法再使用它.为了解决这一问题,内核引入了MDEV框架.
>
> MDEV是一种设备虚拟化技术,允许一个物理设备被“分割”成多个独立的虚拟设备，这些虚拟设备可以被独立地分配给不同的虚拟机，从而实现单张物理卡（如GPU、FPGA）的多用户共享。
>
> VFIO-MDEV模块正是连接通用MDEV框架与VFIO体系的桥梁.
>
> 主要功能 : VFIO-MDEV驱动一个被虚拟出来的mdev设备封装成标准的vfio\_device,最终呈现给用户空间.

## 通用的MDEV框架

\*\*MDEV核心框架(mdev\_init)\*\*独立于VFIO,提供了一套通用的、用于创建和管理虚拟设备的基础设施.

*   **注册MDEV总线(mdev\_bus\_register)** : 创建一个名为mdev的新总线类型.所有通过MDEV框架创建的虚拟设备都将挂在到这条总线上
*   **注册VFIO的MDEV驱动(mdev\_register\_driver)** :将 vfio\_mdev\_driver 注册到内核中。这个驱动的作用就是等待并绑定到任何出现在 mdev总线上的新设备.

## VFIO-MDEV驱动

> **vfio-mdev**自身不实现任何复杂的设备访问逻辑，它只是一个“转发器”。它自动探测由用户创建的 mdev 实例，将其无缝地包装成一个标准的 vfio\_device，并以代理模式将所有设备操作请求转发给底层的物理驱动。
>
> 一旦新的 mdev 设备出现在 mdev 总线上，总线核心会自动为其寻找匹配的驱动。由于 vfio\_mdev\_driver 是注册在该总线上的驱动，其 .probe 函数 vfio\_mdev\_probe 将被执行。

*   vfio\_mdev\_probe 是连接 MDEV 和 VFIO 的关键枢纽。
*   它调用 vfio\_init\_group\_dev，这是一个我们熟悉的函数（在vfio-pci分析中也见过），它的作用是为这个 mdev 设备创建一个对应的 vfio\_group\_dev（即vfio\_device）。
*   在初始化过程中，它将 vfio\_mdev\_dev\_ops 这套操作函数集与新创建的 vfio\_device 关联起来。
*   这一步的逻辑与物理设备被 vfio-pci 绑定时的流程高度相似，最终都产出了一个标准的、可被VFIO核心层管理的 vfio\_device。

